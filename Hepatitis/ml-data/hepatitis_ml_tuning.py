# -*- coding: utf-8 -*-
"""hepatitis_ml_tuning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I254if8EeJ5gENK9V0w1tH64HafNKu16

## 1. Tratamento de dados

### Importação dos dados usando o pandas e colocada suas labels
"""

import pandas as pd
import numpy as np

def replaceBinary(df,min=1,max=2):
    media = df.mean()
    df = df.replace(df.loc[np.logical_and(df>1, df<2)],int(media))
    df = df.replace(to_replace=min, value=0)
    df = df.replace(to_replace=max, value=1)
    return df


url = 'http://archive.ics.uci.edu/ml/machine-learning-databases/hepatitis/hepatitis.data'
labels = ['Class', 'Age', 'Sex', 'Steroid', 'Antivirals', 'Fatigue', 'Malaise', 'Anorexia', 'LiverBig', 'LiverFirm', 'SpleenPalpable', 'Spiders', 'Ascites','Varices','Bilirubin','AlkPhosphate','Sgot', 'Albumin', 'Protime', 'Histology']
df = pd.read_csv(url, 
                 names=labels, header=None)
print(df.head())
df.describe()

"""### Tratamento dos não preenchidos, representados com [?]

Checo os valores que não são int e sim object (strings) e crio uma lista
"""

cols = df.columns[df.dtypes.eq('object')]

"""Percorro cada um object e transformo em numérico, caso não seja numérico o campo fica com NaN
<br>
Assim que é preenchido com NaN eu checo se a coluna é de inteiros caso positivo, eu faço um round para inteiro da média da coluna, caso seja um float eu preencho o NaN com a média
"""


for col in cols:
  df[col] = pd.to_numeric(df[col], errors='coerce')
  if df[col].dtypes == 'int64':
    avg = round(df[col].mean())
    df[col] = df[col].fillna(avg)
  else:
    avg = df[col].mean()
    df[col] = df[col].fillna(avg)
  
df["Class"] = replaceBinary(df["Class"])
df["Sex"] = replaceBinary(df["Sex"])
df["Steroid"] = replaceBinary(df["Steroid"])
df["Antivirals"] = replaceBinary(df["Antivirals"])
df["Fatigue"] = replaceBinary(df["Fatigue"])
df["Malaise"] = replaceBinary(df["Malaise"])
df["Anorexia"] = replaceBinary(df["Anorexia"])
df["LiverBig"] = replaceBinary(df["LiverBig"])
df["LiverFirm"] = replaceBinary(df["LiverFirm"])
df["SpleenPalpable"] = replaceBinary(df["SpleenPalpable"])
df["Spiders"] = replaceBinary(df["Spiders"])
df["Ascites"] = replaceBinary(df["Ascites"])
df["Varices"] = replaceBinary(df["Varices"])
df["Histology"] = replaceBinary(df["Histology"])

"""### Separação dos inputs(x) e dos outputs(y)"""

x = df.loc[:, 'Age':]

y = df.loc[:,'Class']

"""## 2. Aprendizado de Máquina"""

import keras
import tensorflow as tf
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import GridSearchCV

device_name = tf.test.gpu_device_name()
print(device_name)

def criarRede(optimizer, loss, kernel_initializer, activation, neurons, dropout):
  with tf.device('/device:GPU:0'):
    model = Sequential()
    model.add(Dense(units=neurons, activation=activation, kernel_initializer=kernel_initializer, input_dim = 19))
    model.add(Dropout(dropout))   
    model.add(Dense(units=neurons, activation=activation, kernel_initializer=kernel_initializer))  
    model.add(Dropout(dropout))   
    model.add(Dense(units=1, activation= 'sigmoid'))
    model.compile(optimizer=optimizer, loss=loss,
                        metrics = ['accuracy'])
  return model

"""Tuning, testando melhor combinação para o modelo + validação cruzada"""

model = KerasClassifier(build_fn=criarRede)
parametros = {
    'batch_size': [10],
    'epochs': [200],
    'optimizer': ['adam'],
    'loss': ['binary_crossentropy', 'poisson'],
    'kernel_initializer': ['random_uniform'],
    'activation': ['relu'],
    'neurons': [16, 32],
    'dropout': [0.2,0.3,0.4]
}

grid_search = GridSearchCV(estimator=model, param_grid=parametros, scoring='accuracy', cv=5)
grid_search = grid_search.fit(x, y)
melhores_parametros = grid_search.best_params_
melhor_precisao = grid_search.best_score_